# Хеширование

Хеширование - это преобразование данных **произвольного размера** в последовательность **фиксированного размера**, проводимое специальным алгоритмом. Результат работы хеш функции - это **хеш значение** или **хеш ключ**

![alt text](./pictures/hash_principe.png)

Даже небольшие изменения во входных данных приводят к большим изменениям в хеш-значениях. Такой эффект называется **лавинообразным эффектом** и является одной из характеристик хорошей хеш-функции.

### Свойства хеш функций

- **Коллизия хеш-функции** - колизия хеш функции, это когда **хеш значения совпадают** у двух разных наборов данных. Коллизии существуют **для большинства хеш-функций**, но для **хороших хеш-функций частота их возникновения сведена к минимуму**.
- **Детерминированность хеш функции** - свойсво хеш функции, означает что для одинаковых входных данных, хеш ключ тоже будет одинаковым.
- **Невозможность востановить входные данные** - по хеш ключу невозможно восстановить входные данные. ([прикольная статья](https://secureflow.ru/guides/hash-functions-explained?ysclid=mia4lmrefi907265521))

> Но из-за **колизий** мы **не можем однозначно** сказать что равенсво хеш ключей - это равенство входных данных.

### Свойства хорошей хеш функции

- **Лавинообразный эффект**. Небольшое изменение входных данных должно существенно изменять хеш-значение
- **Быстрое вычисление**. Поскольку хеш-функции используются при построении хеш-таблиц, а они используются для быстрого поиска данных, то сама хеш-функция должна работать очень быстро
- **Минимальное количество коллизий**. Хеш-функция не должна возвращать много одинаковых значений для разных входных данных
- **Равномерное распределение хешей**. Хеш-функция должна равномерно распределять хеш-значения при большом количестве входных данных, тем самым минимизируя количество коллизий и эффективно используя весь доступный диапазон чисел (это если хеш возвращяет числа)

### Примеры области применения хеш функций

- **Проверка целостности данных** - при передаче набора данных, так же передается хеш ключ, **если захешированный набор данных совпадает с переданных хеш ключом, набор данных был получен полностью** (это называется контрольная сумма)

- **Работа с большим объемом информации** - построчное сравнение строк, для понимая есть ли там уже строка. (скорее всего тут алгоритмически проще чем посимвольное сравнение, но я пока этого не знаю)

- **Хранение паролей** - в целях безопастности, пароли не храняться в открытом виде, а храняться их хеш значения. И сравниваются также их значения. (по хешу невозможно расшифровать первоначальное значение)

### Встроенная функция `hash()`

Встроенная функция `hash()` - возвращает **целое число**, представляющее хеш-значение переданного объекта.

> Для более сложных типов данных, например, str, встроенная функция `hash()` возвращает **новое хеш-значение при каждом новом запуске программы**. То есть фунция дкткрминирована только в рамках одного запуска. *Дело в том, что Python по умолчанию использует рандомизацию хешей для некоторых типов (например, str), чтобы сделать хеш-значения менее предсказуемыми.*

- Функция `hash()` не работает с **изменениемыми** типами данных (**list**, **set**, **dict**)
- Функция работает с **tuple** только если ее елементы являются **НЕизменяемыми**.
- Функция также работает с **frozenset**, т.к.

## Хешируемость и изменяемость

> Хешируемость объектов играет важную роль в Python. В частности, от того, **является ли объект хешируемым**, зависит возможность его использования в качестве ключа в словаре, а также его возможность быть элементом множества.

> Если тип является хешируемым, то он должен быть неизменяемым, **иначе могут возникнуть проблемы**.

## Хеширование пользовательских классов

По умолчанию в пользовательских классах сравнение на равенство является сравнением на идентичность. Другими словами, если в классе не определено, как будет происходить сравнение с помощью оператора `==`, оно будет равносильно сравнению с помощью оператора `is`.

> Идентичность объекта определяется с помощью функции `id()`. Другими словами, объекты идентичны, если они имеют одинаковый идентификатор во время выполнения программы.

- По умолчанию все пользовательские классы являются хешируемыми и имеют реализованный магический метод `__hash__()`, который и вызывает встроенная функция `hash()`.

- Поскольку у равных объектов должны быть равны и хеш-значения, то магический метод `__hash__()` **по умолчанию использует идентификатор объекта**. А именно, базовая реализация метода `__hash__()` возвращает значение `id(obj) // 16`.

Например:

```py
class Point:
    def __init__(self, x, y):
        self._x = x
        self._y = y


p1 = Point(1, 2)
p2 = Point(1, 2)

print(hash(p1), id(p1) // 16)
print(hash(p2), id(p2) // 16)

#> 150672559026 150672559026
#> 150672559032 150672559032
```

### Магический метод `__hash__()`
