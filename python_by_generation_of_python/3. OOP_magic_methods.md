# Магические методы

## Cоздание, инициализация и очищение объектов

**Магические методы** - это методы которые вносят в классы **специальный** (*магический*) функционал. Они всегда обрамлены двойными нижними подчеркиваниями до и после названия. Например `__init__`

Магические методы не предназначены для прямого вызова, их вызов происходит **автоматически при определенных условиях.**

### Методы `__new__()` и `__init__()`

Для создания экземпляра класса (объекта) нам достаточно импортировать этот класс и вызвать его как функцию и передать аргументы, если это необходимо `MyClass()`

Когда мы это делаем запускается внутренний процесс **конструирования класса** который состоит из двух этапов:

- создание пустого объекта - **за это отвечает метод `__new__`**
- инициализация этого объекта (то есть присваивание ему его собственных атрибутов) - **за это отвечает метод `__init__`**

> **self** который использует метод `__init__` это как раз и есть пустой объект созданный методом `__new__`

![alt text](./pictures/constructiing_of_class.png)

Вот пример как воссоздать вручную конструирование класса:

```py
class Dog:
    def __new__(cls, *args, **kwargs):
        print('1. Создание экземпляра класса Dog')
        instance = object.__new__(cls)
        return instance

    def __init__(self, name):
        print('2. Инициализация созданного экземпляра класса Dog')
        self.name = name


rex = Dog.__new__(Dog)
Dog.__init__(rex, 'Рекс')
```

> **Добавление нижних подчеркиваний к произвольному методу не сделает его магическим**. Магические методы имеют для интерпретатора особое значение. **Имена магических методов и их смысл определены создателями языка**: создавать новые нельзя, можно только реализовывать существующие.

## Метод `__del__`

`__del__()` - это метод который используется для **финализатора**. Метод который используется для отчистке, освобождению или закрытию ресурсов, которые использовались объектом. (например, открытые файлы или соединения)

> **Финализатор** в питоне **вызывается автоматически**, когда **количество ссылок на объект становиться равным нулю**.

## Строковое представление объектов

### Функции str() и repr()

Функции `str()` и `repr()` спользуются для получения строкового представления объекта.

- `str()` используется для получения **неформального** (ту что понимает человек) представления
- `repr()` используется для получения **формального** (ту что понимает интерпритатор, то есть сможет выполнить. Например через функцию `eval()` ) представления

Например:

```py
from datetime import date

dt = date(2022, 10, 23)

print(str(dt)) #> 2022-10-23
print(repr(dt)) #> datetime.date(2022, 10, 23)
```

> Если объект передается **в функцию print()** в качестве самостоятельного аргумента, то **для его отображения автоматически вызывается функция str()**

### Магические методы `__str__()` и `__repr__()`

Магические методы `__str__()` и `__repr__()` используются для строковых представлений при вызове функций `str()` и `repr()`

> Принято, что метод **repr**() должен возвращать строку, которую можно преобразовать обратно в объект с помощью функции `eval()` (выполнение кода python в строковом представлении)

> Методы **str**() и **repr**() **всегда должны возвращать объект типа str**, в противном случае будет возбуждено исключение TypeError.

Пример реализации в собственном классе:

```py
class Dog:
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return f"Собака по имени {self.name}"
    def __repr__(self):
        return f"Dog('{self.name}')"

rex = Dog("Rex")

print(str(rex)) #> Собака по имени Rex
print(repr(rex)) #> Dog('Rex')
```

## Сравнение объектов

### Магические методы `__eq__()` и `__ne__()`

Если мы самостоятельно не определим методы для сравнения объектов, то сравнение с помощью оператора `==` будет равносильно `is`. То есть **сравнение на равенство** будет являеться **сравнением на идентичность**

Сравнение на идентичность `is` - это являются ли ссылки присвоенные переменным ссылками на **один и тот же экземпляр класса**

**Магический метод `__eq__()`** определяет как именно будут сравниваться два объекта при применении к ним `==`. Метод `__eq__` вызывается у левого объекта, а в качестве аргумента ему передается другой объект. То есть `class1 == class2` идентично `class1.__eq__(class2)`

![alt text](./pictures/equal.png)

Хорошим примером применения метода сравнения можно увидеть на классах тоек координат:

```py
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y
```

Здесь сравнение происходят по координатам присвоенным объектам.

Для того чтобы не получать ошибку при сравнении объектов разных классов стоит включить проверку на класс при реализации метода:

```py
def __eq__(self, other):
    if isinstance(other, Point):
        return self.x == other.x and self.y == other.y
    else:
        return False
```

> Метод `eq()`, помимо сравнения с помощью оператора `==`, также вызывается при проверке на принадлежность с помощью оператора `in`

> Если пользовательский класс переопределяет магический метод `__eq__()`, то он дополнительно должен переопределить магический метод `__hash__()` таким образом, чтобы равные объекты имели равные хеш-значения. (об этом в [отделельном файле](4.%20OOP_hashing.md))
---
---

**Магический метод `__ne__()`** - используется для сравнение на неравенство с помощью оператора `!=`

```py
def __ne__(self, other):
    if isinstance(other, Point):
        return self.x != other.x or self.y != other.y
    else:
        return True
```

> **Python автоматически реализует метод **ne**(), если метод **eq**() уже реализован**

Онако если нам требуется несколько иная реализация, мы всегда можем определить метод `__ne__()` вручную.

### Константа NotImplemented

Константа `NotImplemented` возвращяется если попытаться вызвать метод `__eq__` у объекта у которого не имплементирован данный метод.

При сравнении с помощью оператора `==` Python автоматически вызовет метод `__eq__` у первого объекта, если ответом будет `True` или `False`, это будет результатом сравнения. Если результатом будет `NotImplemented`, Python вызовет `__eq__` у второго сравниваемого объекта, если и при этом вызове результатом будет `NotImplemented`, то результат сравнения будет определяться исходя из идентичности объектов (`is`).

Именно константу NotImplemented рекомендуется возвращать в методе `__eq__()`, если сравнение для объектов каких-либо типов не определено.

```py
def __eq__(self, other):
    if isinstance(other, Point):
        return self.x == other.x and self.y == other.y
    else:
        return NotImplemented
```

## Магические методы `__lt__()` и `__gt__()`, `__le__()` и `__ge__()`

Методы `__lt__()` и `__gt__()` отвечают за **строгое** сравнение на больше `>` и меньше `<`, соответсвенно.
Например:

```py
def __lt__(self, other):
    if isinstance(other, Fruit):
        return self.mass < other.mass
    return NotImplemented

def __gt__(self, other):
    if isinstance(other, Fruit):
        return self.mass > other.mass
    return NotImplemented
```

Методы `__lt__()` и `__gt__()` отвечают за **нестрогое** сравнение на больше `>=` и меньше `<=`, соответсвенно.

```py
def __le__(self, other):
    if isinstance(other, Fruit):
        return self.mass <= other.mass
    return NotImplemented

def __ge__(self, other):
    if isinstance(other, Fruit):
        return self.mass >= other.mass
    return NotImplemented
```

### Декоратор `@total_ordering`

Можно не имплементировать каждый из четырех методов `__lt__()`, `__gt__()`, `__le__()`, `__ge__()` можно воспользоваться декоратором класса `@total_ordering` из модуля **functools**. Для его использования нужно имплментировать метод `__eq__` и любой из четырех методов.

Например:

```py
from functools import total_ordering

@total_ordering
class Fruit:
    def __init__(self, name, mass):
        self.name = name
        self.mass = mass

    def __eq__(self, other):
        if isinstance(other, Fruit):
            return self.mass == other.mass
        return NotImplemented

    def __lt__(self, other):
        if isinstance(other, Fruit):
            return self.mass < other.mass
        return NotImplemented
```

> **После реализации** в классе операторов сравнения на больше/меньше **появляется возможность сортировать** экземпляры этого класса и выбирать среди них наименьший/наибольший.

## Унарные операторы и функции

Унарные - значит работающие с одним операндом.

Унарные операторы - `+`, `-` и `~`
Поведение для унарных операторов
`__pos__()` — определяет поведение для унарного плюса
`__neg__()` — определяет поведение для унарного минуса
`__invert__()` — определяет поведение для оператора инвертирования

> Унарные операторы **возвращают новые объекты того же класса**, а не изменяют исходный

```py
class Angle:
    def __init__(self, value):
        self.value = value                       # градусная мера угла

    def __repr__(self):
        return f'Angle({self.value})'

    def __pos__(self):
        return Angle(self.value)

    def __neg__(self):
        return Angle(-self.value)

    def __invert__(self):
        if 0 <= self.value <= 180:
            return Angle(180 - self.value)
        return Angle(180 + self.value)


angle = Angle(100)

print(+angle) # 100
print(-angle) # -100
print(~angle) # 80
```

---

- `__abs__()` — определяет поведение для встроенной функции `abs()`  
- `__round__()` — определяет поведение для встроенной функции `round()`; помимо экземпляра класса метод принимает необязательный аргумент n, который, как правило, означает количество знаков после запятой после округления  
- `__trunc__()` — определяет поведение для функции `trunc()` из модуля math  
- `__floor__()` — определяет поведение для функции `floor()` из модуля math  
- `__ceil__()` — определяет поведение для функции `ceil()` из модуля math  

```py
import math

class Angle:
    def __init__(self, value):
        self.value = value

    def __repr__(self):
        return f'Angle({self.value})'

    def __abs__(self):
        return Angle(abs(self.value))

    def __round__(self, n=None):
        if n is None:
            return Angle(round(self.value))
        return Angle(round(self.value, n))

    def __trunc__(self):
        return Angle(math.trunc(self.value))

    def __floor__(self):
        return Angle(math.floor(self.value))

    def __ceil__(self):
        return Angle(math.ceil(self.value))


angle = Angle(-101.54)

print(abs(angle))
print(round(angle))
print(round(angle, 1))
print(math.trunc(angle))
print(math.floor(angle))
print(math.ceil(angle))
```

## Арифметические операции

Для того чтобы разрешить совершать арифметические операторы с вашими классами (или другие операции, но с ипользрванием арифметических операторов, типа `+`), нужно определять

- `__add__()` — определяет поведение для сложения (оператор `+`)
- `__sub__()` — определяет поведение для вычитания (оператор `-`)
- `__mul__()` — определяет поведение для умножения (оператор `*`)
- `__truediv__()` — определяет поведение для обычного деления (оператор `/`)
- `__floordiv__()` — определяет поведение для целочисленного деления (оператор `//`)
- `__mod__()` — определяет поведение для деления по модулю (оператор `%`)

> Результатами арифметических операций **являются новые объекты того же класса**.

### Отраженные арифметические операции

Если наш класс будет учавствовать в арифметической оператции как **правый** операнд, мы можем получать исключение т.к. у **левого операнда не прописано взаиможействие** с нашим классом.

Например:

```py
class PiggyBank:
    def __init__(self, coins):
        self.coins = coins

    def __add__(self, other):
        return PiggyBank(self.coins + other)


bank = PiggyBank(10)

print(5 + bank)
```

Приводит к возбуждению исключения TypeError, т.к. `5 + bank` преобразуется в вызов `(5).__add__(bank)`, а для типа `int` не реализовано сложение с типом `PiggyBank`

Для реализации арифметических операций, не учитывающих порядок операндов, в Python доступен дополнительный набор магических методов с префиксом `r`:

- `__radd__()` — определяет поведение для сложения (оператор `+`)
- `__rsub__()` — определяет поведение для вычитания (оператор `-`)
- `__rmul__()` — определяет поведение для умножения (оператор `*`)
- `__rtruediv__()` — определяет поведение для обычного деления (оператор `/`)
- `__rfloordiv__()` — определяет поведение для целочисленного деления (оператор `//`)
- `__rmod__()` — определяет поведение для деления по модулю (оператор `%`)

Например:

```py
class PiggyBank:
    def __init__(self, coins):
        self.coins = coins

    def __add__(self, other):
        return PiggyBank(self.coins + other)

    def __radd__(self, other):
        print('Вызов метода __radd__()')
        return self.__add__(other)
```

> При любой арифметической операции **сначала происходит попытка вызвать основную версию** магического метода (без префикса r) у первого операнда, и если он не определен явно или при его вызове была возвращена константа `NotImplemented`, **происходит попытка вызова отраженной версии магического метода** (с префиксом r) у второго операнда.

### Операции двоичного сдвига и логические операции

- `__lshift__()` — определяет поведение для двоичного сдвига влево (оператор `<<`)
- `__rshift__()` — определяет поведение для двоичного сдвига вправо (оператор `>>`)
- `__and__()` — определяет поведение для двоичного И (оператор `&`)
- `__or__()` — определяет поведение для двоичного ИЛИ (оператор `|`)
- `__xor__()` — определяет поведение для двоичного XOR, (оператор `^`)

> Все приведенные выше методы также имеют отраженные версии (с префиксом `r`).

## Операции составного присваивания

**Операторы составного присваивания** (`+=`, `-=`, `*=`, и т.д.) в отличие от арифметических операторов (к*оторые всегда возвращяют новый экземпляр*), **могут изменять исходный объект** (в случае если он изменяем, конечно)

- `__iadd__()` — определяет поведение для сложения (оператор `+=`)
- `__isub__()` — определяет поведение для вычитания (оператор `-=`)
- `__imul__()` — определяет поведение для умножения (оператор `*=`)
- `__itruediv__()` — определяет поведение для обычного деления (оператор `/=`)
- `__ifloordiv__()` — определяет поведение для целочисленного деления (оператор `//=`)
- `__imod__()` — определяет поведение для деления по модулю (оператор `%=`)

**Если экземпляр класса являются изменяемыми**, результатом операции должен являться **измененный исходный экземпляр**.

```py
class PiggyBank:
    def __init__(self, coins):
        self.coins = coins

    def __iadd__(self, other):
        self.coins += other
        return self

bank = PiggyBank(10)
bank += 10
bank += 5

print(bank) # 25
```

> Если в классе определены арифметические операторы и не определены магические методы с **i** (*inplace*), то операторами составного присваивания можно пользоваться, но результатов всегда будет новый экземпляр.

## Вызываемые объекты

Некоторые объекты можно *вызывать*, например функцию.

```py
def funny_func():
    print("ha-ha")

funny_func() # здесь мы вызвали функцию
```

Вызывать можно не только функции, но и объекты класса. Для этого существует магический метод `__call__()`

### Метод `__call__()`

`__call__()` - метод для создания создания собственных вызываемых объектов. Данный метод позволяет экземплярам класса вести себя так, **как будто они функции**, то есть мы можем вызывать их, передавать их в функции, которые ожидают в качестве аргумента функцию, и так далее

Например:

```py
class Dog:
    def __init__(self, name):
        self.name = name                   # имя кошки

    def __call__(self):
        print('Меня зовут', self.name)


rex = Dog('Рекс')

rex() # Меня зовут Рекс
```

Проверить есть ли у объекта метод `__call__`, что соответвует тому что объект **вызываемый**, можно так:
`print(hasattr(int, '__call__'))`
или сразу проверить на **вызываемость** `print(callable(int))`

## Преобразование типов

### `__bool__()`

В питоне любой объект можно привести к булеву типу с помощью функции `bool()`.  
Любое **ненулевое число** или любой **непустой список** преобразуются в значение `True`.

Однако при использовании функции `bool()` к собственному экземпляру класса всегда будет выдавать `True` вне зависимости от состаяния экземпляра.

То как как будет преобразован экземпляр определяется в магическом методе `__bool__()`

Например:

```py
class Angle:
    def __init__(self, value):
        self.value = value

    def __bool__(self):
        return self.value > 0
```

Метод `__call__()` вызывается при проверке на истинность с помощью условного оператора `if`.

> Если в классе не реализован метод `__bool__()`, то происходит попытка вызова метода `__len__()`, и если он реализован и возвращает ненулевое значение, то объект считается истинным, в противном случае объект считается ложным.

### Методы `__int__()`, `__float__()` и `__complex__()`

- `__int__()` — определяет поведение экземпляра при передаче в функцию int(). Метод должен возвращать значение, соответствующее преобразованию экземпляра в тип int
- `__float__()` — определяет поведение экземпляра при передаче в функцию float(). Метод должен возвращать значение, соответствующее преобразованию экземпляра в тип float
- `__complex__()` — определяет поведение экземпляра при передаче в функцию complex(). Метод должен возвращать значение, соответствующее преобразованию экземпляра в тип complex

Например:

```py
class Angle:
    def __init__(self, value):
        self.value = value

    def __int__(self):
        return int(self.value)

    def __float__(self):
        return float(self.value)
```

## Работа с атрибутами объектов

При установке, получении и удалении атриутов неявно вызываются следующие магические методы:

- `__getattribute__()` — вызывается при обращении к любому атрибуту
- `__getattr__()` — вызывается при обращении к несуществующему атрибуту
- `__setattr__()` — вызывается при установке атрибута или изменении его значения
- `__delattr__()` — вызывается при удалении любого атрибута

> Метод `__getattribute__()` может либо сам вызвать метод `__getattr__()`, либо возбудить исключение AttributeError, и тогда метод `__getattr__()` будет вызван автоматически
