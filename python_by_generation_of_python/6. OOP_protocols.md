# Протоколы

## Протокол итерируемых обектов и итераторов

Подробнее об этом в [Iterators_and_generators](./Iterators_and_generators.md)

## Протокол последовательностей

**Последовательности** — коллекции, элементы которых пронумерованы индексами и расположены в строгом порядке.

**Последовательностью** считается объект, поддерживающий следующие операции:

- индексация
- срезы
- проверка на принадлежность (оператор `in`)
- наличие длины (`len`)
- итерирование
Например: `list`, `str`, `tuple` и `range`

Для создания **собственной последовательности**, нам нужно создать класс **поддерживающий все вышеперечисленные операции**, путем добавления в него **соответсвующих магических методов**.

### Неизменяемая последовательность

Для создания неизменяемой последовательности нам нужно определить следующие методы:

- `__len__()` - определяет поведения при передаче объекта в функцию `len()`
- `__getitem__()` - определяет поведение объекта при обращениии к эллементу через `sekf[key]`(**индексация**)
- `__iter__()` - возвращяет итератор и определяет поведение при передаче в функцию `iter()`
- `__contains__()` - определяет поведение при проверке на принадлежность с помощью `in` или `not in`

Пример реализации класса - неизменяемой последовательности:

```py
class PersonalToDoList:
    def __init__(self, to_do_list : list, person : str):
        self.to_do_list = list(to_do_list)
        self.person = person
    
    def __len__(self):
        return len(self.to_do_list)
    
    def __getitem__(self, index):
        if not isinstance(index, int):
            raise TypeError("The index must be int")
        if index < 0 or index > len(self.to_do_list):
            raise IndexError("Wrong index")
        else:
            return self.to_do_list[index]
    
    def __iter__(self):
        yeild from self.to_do_list
    
    def __contains__(self, item):
        return item in self.to_do_list
```

### Изменяемая последовательность

Для создания изменяемой последовательности к вышеописанным методам нужно добавить:

- `__setitem__()` - определяет поведение значение при присваивании значения элементу последовательности, `self[key] = value`
- `__delitem__()` - определяет поведение при удалении элемента последовательности, с помощью `del`

Рассмотрим добавлении методов в тот же класс:

```py
class PersonalToDoList:
    ...
    ...
    ...
    ...

    def __setitem__(self, key, value):
        self.to_do_list[key] = value
    
    def __delitem__(self, key):
        del self.to_do_list[key]
```

### Срезы последовательностей

Для начала нужно разобрать как работает функция `slice()` именно с помощью нее реализуются срезы при создании классов.

Функция `slice()` возвращяет объект типа `slice`.
Именно эти объекты автоматически создаются и указываются в качестве индексов, когда мы используем синтаксис срезов.

Объект `slice` напоминает объект `range`, он также как и рейндж имеет атрибуты `start`, `stop`, `step`.

Например:

```py
slice1 = slice(10) # start=None, stop=10, step=None  
slice2 = slice(1, 10) # start=1, stop=10, step=None
slice3 = slice(1, 10, 2) # start=1, stop=10, step=2
```

Таким образом **чтобы реализовать поддержку срезов** нужно в методах `__getitem__()`, `__setitem__()`, `__delitem__()` предусмотреть **поддержку объектов `slice`**

> **При срезе должен возвращятся новый объект с эллементами последовательности только из среза**

Например:

```py
class PersonalToDoList:
    ...
    ...
    ...
    ...

    def __getitem__(self, key):
        if isinstance(key, slice):
            return self.__class__(self.to_do_list[key], self.person)
```

Аналогичным образом можно реализовать методы `__setitem__()` и `__delitem__()`, чтобы пользоваться срезами и в них.

## Оператор `with`

При работе **внешними ресурсами** (файлами, БД и т.д.) важно своевременно их особобождать (закрывать).

Работа с файлом и его ручное *освобождение*:

```py
file = open('output.txt', mode='w', encoding='utf-8')
file.write('Python generation!')
file.close()
```

Однако ручное закрытие файлов или прочих внешних ресурсов, обладают существенным недостатком:

- Если между открытием файла и его закрытием будет **возбуждено исключение**, то файл может **остаться открытым и недоступным для других процессов**

Для того чтобы гарантировать закрытие внешнего ресурса, можно использовать конструкцию `try-finally`:

```py
file = open('output.txt', mode='w', encoding='utf-8')

try:
    file.write('Python generation!')
finally:
    file.close()
```

Блок `finally` гарантированно закроет файл.
