# Атрибуты и методы классов и объектов

> **Объект** здесь имеется ввиду конкретный экземпляр класса

То есть не абстракция (класс), а именно его  конкретная  единица (объект/экземпляр)

> **Названия классов** пишуться в **PascalCase** (PEP 8)

> **Название атрибутов и методов** пишут в **snake_case** (PEP 8)

## Атрибуты

### Атрибуты объектов

К каждому объекту можно присвоить произвольный атрибут. например

```py
class Cat:
    pass

catOne = Cat()
catTwo = Cat

catOne.name = "Tom"
catTwo.color = "Orange"
```

Так у объекта catOne, появился атрибут `name`, а у второго атрибут `color`. При попытке вызвать у объекта атрибут которого у него нет, мы возбудим исключение `AttributeError`

### Атрибуты классов

Атрибуты можно установить на уровне класса, следовательно все объекты будут иметь эти атрибуты по умолчанию

```py
class Cat:
    is_there_night_vision = True
```

### `__dict__` и `__doc__`

Все атрибуты **объекта** или класса храняться в служебном атрибуте `__dict__`. Атрибуты объекта и атрибуты класса - это разные вещи.

Соответсвенно можно получить все атрибуты объекта или класса можно через `__dict__`

В атрибуте `__doc__` храниться строка документации класса

### Функции работающие с атрибутами

- `getattr(obj, name, default)` - возвращяет атрибут с именем **name** из объекта **obj**, при отсутсвии такового возвращяет **default**
- `setattr(obj, name, value)` - исходя из названия,устанавливает объекту obj атрибут name со значением value
- `delattr(obj, name)` - удаляет атрибут
- `hasattr(obj, name)` - True если у объекта есть атрибут с запрашиваемым именем и False в противном

## Методы экземпляра

### `__self__`

Для создания метода, необходимо создать функцию внутри тела класса, с минимумом одним параметром. И первым параметров всегда должен идти `self`

`self` - это ссылка на экземпляр класса, который будет использовать в дальнейшем использовать метод. Его указание подчеркивает, что что метод применяется к **конкретному экземпляру класса**. То есть все атрибуты которые будут использованы в дальнейшем будут конкретного экземпляра, а не всего класса.

### `__init__`

Метод `__init__` - это так называемый метод инициализации, он существует для того чтобы **указать обязательные параметры** для создания экземляра класса.

Также т.к. метод `__init__()` исполняется сразу после создания объекта, в этот метод можно заложить **обязательные действия** при создание объекта.

Это позволяет сразу же наделить новосозданный объект необходимыми атрибутами. (но прописывать это нужно самостоятельно)

```py
class Cat():
    def __init__(self, name):
        self.name = name

some_cat = Cat() # тут будет TypeError т.к. метод инит требует указание параметра name
tom = Cat("Tom") # объект с атрибутом name = "Tom"
```

>Сигнатура метода `__init__()` полностью повторяет сигнатуру любой функции. С помощью `*args` и `**kwargs` метод `__init__()` может принимать произвольное количество позиционных и именованных аргументов соответственно.

## Модификаторы доступа

В классических языках программирования (C++, Java, C#) доступ к атрибутам реализуется с помощью ключевых слов `public` (публичный), `protected` (защищенный) и `private` (приватный):

- `public` - это **публичные** атрибуты доступные из вне класса
- `protected` - это **защищенные**  атрибуты, доступ к которым возможен из текущего класса и из классов потомков
- `private` - это **приватный** атрибут с ним можно работать из текущего класса

> **В python нет механизма запрещающего работать с атрибутами извне**

Но есть ряд соглашений:

- `_name` - одно нижнее подчеркивание в начала имени атрибута означает что он `protected` (защищенный)
- `__name` - два нижних подчеркивания в начале имени атрибута - это `private` (приватный)

## Методы акссесоры

> Несмотря на то что механизма по запреду доступа до атрибутов внутри класса как такого нет, все **на практике принято делать все атрибуты класса защищенными или приватными**.

Для изменения защищенный атрибутов создают **публичные** методы которые позволяют это делать. Это делается для того чтобы предусмотреть некие механизмы защиты атрибутов в этих публичных методах.

### Геттер

- Геттер это метод позволяющий получить атрибут без его изменения кодом находящимся вне метода.

### Сеттер

- Сеттер это метод устанавливающий или изменяющий текущие значение атрибута. Метод сеттер может управлять тем **как он изменит атрибут на основании переданного значения**. Это означает что в метод можно заложить некие проверки

### Делитер

- Делитер это метод который удаляет атрибут из объекта
