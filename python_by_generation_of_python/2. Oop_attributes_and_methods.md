# Атрибуты и методы классов и объектов

> **Объект** здесь имеется ввиду конкретный экземпляр класса

То есть не абстракция (класс), а именно его  конкретная  единица (объект/экземпляр)

> **Названия классов** пишуться в **PascalCase** (PEP 8)

> **Название атрибутов и методов** пишут в **snake_case** (PEP 8)

## Атрибуты

### Атрибуты объектов

К каждому объекту можно присвоить произвольный атрибут. например

```py
class Cat:
    pass

catOne = Cat()
catTwo = Cat

catOne.name = "Tom"
catTwo.color = "Orange"
```

Так у объекта catOne, появился атрибут `name`, а у второго атрибут `color`. При попытке вызвать у объекта атрибут которого у него нет, мы возбудим исключение `AttributeError`

### Атрибуты классов

Атрибуты можно установить на уровне класса, следовательно все объекты будут иметь эти атрибуты по умолчанию

```py
class Cat:
    is_there_night_vision = True
```

### `__dict__` и `__doc__`

Все атрибуты **объекта** или класса храняться в служебном атрибуте `__dict__`. Атрибуты объекта и атрибуты класса - это разные вещи.

Соответсвенно можно получить все атрибуты объекта или класса можно через `__dict__`

В атрибуте `__doc__` храниться строка документации класса

### Функции работающие с атрибутами

- `getattr(obj, name, default)` - возвращяет атрибут с именем **name** из объекта **obj**, при отсутсвии такового возвращяет **default**
- `setattr(obj, name, value)` - исходя из названия,устанавливает объекту obj атрибут name со значением value
- `delattr(obj, name)` - удаляет атрибут
- `hasattr(obj, name)` - True если у объекта есть атрибут с запрашиваемым именем и False в противном

## Методы экземпляра (или объекта)

### `__self__`

Для создания метода, необходимо создать функцию внутри тела класса, с минимумом одним параметром. И первым параметров всегда должен идти `self`

`self` - это ссылка на экземпляр класса, который будет использовать в дальнейшем использовать метод. Его указание подчеркивает, что что метод применяется к **конкретному экземпляру класса**. То есть все атрибуты которые будут использованы в дальнейшем будут конкретного экземпляра, а не всего класса.

### `__init__`

Метод `__init__` - это так называемый метод инициализации, он существует для того чтобы **указать обязательные параметры** для создания экземляра класса.

Также т.к. метод `__init__()` исполняется сразу после создания объекта, в этот метод можно заложить **обязательные действия** при создание объекта.

Это позволяет сразу же наделить новосозданный объект необходимыми атрибутами. (но прописывать это нужно самостоятельно)

```py
class Cat():
    def __init__(self, name):
        self.name = name

some_cat = Cat() # тут будет TypeError т.к. метод инит требует указание параметра name
tom = Cat("Tom") # объект с атрибутом name = "Tom"
```

>Сигнатура метода `__init__()` полностью повторяет сигнатуру любой функции. С помощью `*args` и `**kwargs` метод `__init__()` может принимать произвольное количество позиционных и именованных аргументов соответственно.

## Модификаторы доступа

В классических языках программирования (C++, Java, C#) доступ к атрибутам реализуется с помощью ключевых слов `public` (публичный), `protected` (защищенный) и `private` (приватный):

- `public` - это **публичные** атрибуты доступные из вне класса
- `protected` - это **защищенные**  атрибуты, доступ к которым возможен из текущего класса и из классов потомков
- `private` - это **приватный** атрибут с ним можно работать из текущего класса

> **В python нет механизма запрещающего работать с атрибутами извне**

Но есть ряд соглашений:

- `_name` - одно нижнее подчеркивание в начала имени атрибута означает что он `protected` (защищенный)
- `__name` - два нижних подчеркивания в начале имени атрибута - это `private` (приватный)

## Методы акссесоры

> Несмотря на то что механизма по запреду доступа до атрибутов внутри класса как такого нет, все **на практике принято делать все атрибуты класса защищенными или приватными**.

Для изменения защищенный атрибутов создают **публичные** методы которые позволяют это делать. Это делается для того чтобы предусмотреть некие механизмы защиты атрибутов в этих публичных методах.

### Геттер

- Геттер это метод позволяющий получить атрибут без его изменения кодом находящимся вне метода.

### Сеттер

- Сеттер это метод устанавливающий или изменяющий текущие значение атрибута. Метод сеттер может управлять тем **как он изменит атрибут на основании переданного значения**. Это означает что в метод можно заложить некие проверки

### Делитер

- Делитер это метод который удаляет атрибут из объекта

## Свойства (property)

Свойства класса - это среднее между методом и атрибутом. Они существуют для упрощения работы с атрибутами.

Для создания **свойств** используется встроенная функция `property()`:
`property(fget = None, fset = None, fdel = None, doc = None)`

- `fget` — функция для получения значения атрибута (геттер)
- `fset` — функция для установки значения атрибута (сеттер)
- `fdel` — функция для удаления атрибута (делитер)
- `doc` — строка документации

Создание `property`:

```py
class Cat:
    def __init__(self, name):
        self._name = name

    def get_name(self):
        return self._name

    def set_name(self, name):
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')

    name = property(get_name, set_name)  
```

> Теперь работать с атрибутом `_name` можно через свойство `name`. При этом **во время обращения к свойству `name`** как к атрибуту (`self.name`) **будет неявно вызываться метод `get_name()`**

> А во время **установки значения свойству `name` как атрибуту** (`self.name = value`) будет **неявно вызываться метод `set_name()`**, которому в качестве аргумента будет передано значение value.

Если будет определено свойство объекта и **не будет указан один из параметров** в методе `property` (fget, fset, fdel), то попросту **невозможно будет получить, установить или удалить атрибут, в зависимости от того какой из параметров вы не указали**.

Пример: если не указать fset, `AttributeError: property 'name' of 'Cat' object has no setter
`

### Использование `свойства` в инициализации объекта

```py
class Man:
    def __init__(self, name):
        # здесь мы уже работаем со свойством, т.к. атрибут имеет имя _name
        self.name = name

    def set_name(self, name):
        print("устанавливаю имя")
        self._name = name

    def get_name(self):
        print("выдаю имя")
        return self._name

    name = property(get_name, set_name)

serg = Man("serg")

#> устанавливаю имя
```

## Декоратор `@property`

Объект `property()` был добавлен в Python 2.2. Использование декоратора с помощью символа `@` появился в Python 2.4. С этого момента проперти чаще всего используется именно через декоратор.

Создание проперти с помощью декоратора:

```py
@property
def name(self):
    return self._name
```

Где:

- **название декорируемой функции** это и **имя проперти**
- декорируемая функция **это геттер для проперти**

```py
@name.setter
def name(self, new_name):
    self._name = new_name
```

- для создание сеттера уже используется декоратор `<property_name>.setter`
- имя декорируемой функции должно точно повторять название проперти, иначе будут созданы два проперти

```py
@name.deleter
def name(self):
    del self._name
```

- аналогично и для деллитреа

> - При созданиии сеттера и делитерра для проперти через декоратор - это рименение функции property() в качестве декоратора — это **последовательное создание новых проперти** и переприсваивание **их одной и той же переменной**.

## Методы класса и статические методы

### Методы класса и декоратор `@classmethod`

**Метод класса** в отличие от метода объекта (который работает с конкретным экземпляром класса и его атрибутами) - это функция, которая принадлежит всему классу целиком, а не какому то конкретному экземпляру.

Такие методы имеют **возможность менять состояние класса**, что в свою очередь **отражается на всех экземплярах данного класса**. Однако **они не могут менять состояние конкретного объекта**, так как не имеют доступ к конкретному объекту (self).

> - для создания **метода класса** используется декоратор `@classmethod`
> - Первым параметром **метода класса** должен быть `cls` (класс), а не `self` (объект)

Чаще всего методы класса используются **для создания "альтернативных конструкторов"**.

Пример использования **метода класса**:

```py
class Dog:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed
    
    @classmethod
    def create_dog_with_sheepdog_breed(cls, name):
        return cls(name, "sheepdog")

jessy = Dog("Jessy", "labrador")
rex = Dog.create_dog_with_sheepdog_breed("Rex")

print(jessy.breed) # labrador
print(rex.breed) # sheepdog
```

### Статические методы и декоратор `@staticmethod`

Статические методы - это методы, которые не имеют обязательного параметра `self` или `cls` и соответсвенно **не могут изменять ни состояние объекта, ни состояние класса**.

Статические методы можно считать **обычными функциями, помещенными в тело класса для удобства**

> Для создания статических методов используется декоратор `@staticmethod`

При создании функции внутри тела класса без указания декоратора `@staticmethod`, функция будет считаться методом класса и будет ожидать `self` в качестве первого аргумента

## Обращение к атрибутам и методам класса из экземпляра

Вы можете обратиться к методам и атрибутам класса из экземпляра использяю атрибут `__class__` у экземпляра.

А также можно обращяться к экземпляру из класса через `self`

Например:

```py
class Pet:
    def __init__(self, name):
        self.name = name
        if not self.__class__.first_object:
            self.__class__.first_object = self 
        self.__class__.last_object = self
        self.__class__.num_of_objects += 1
    
    first_object = None
    last_object = None
    num_of_objects = 0
    
    @classmethod
    def first_pet(cls):
        return cls.first_object
    
    @classmethod
    def last_pet(cls):
        return cls.last_object
    
    @classmethod
    def num_of_pets(cls):
        return cls.num_of_pets

rex = Pet("Rex")
jessy = Pet("Jessy")


print(rex.__class__.num_of_objects) # 2
```

## Декоратор `@singledispatchmethod`

### Перезагрузка методов

**Перегрузка методов** — это приём программирования, который позволяет в зависимости от количества переданных в метод аргументов использовать определенную версию метода.

Python, **не поддерживает** перегрузку методов **напрямую**. В Python классы хранят имена методов во внутреннем словаре `__dict__`. Как и любой словарь, `__dict__` не может иметь повторяющихся ключе.

Т.к. `__init__` это тоже метод, то мы не можем перегружать инит и тем самым не можем напрямую перегружать его, но есть несколько путей имитации перезагрузки:

- Использование значений по умолчанию (необязательных аргументов). Это позволит создавать разные классы в зависимости от количества переданных аргументов
- Использование проверки типов у аргументов (`isinctance()`). *Тут конечно можно не только проверку типов делать, но и различные другие проверки внутри `if else`*
- Использование **методов класса**.
- Использование декоратора `@singledispatchmethod`

### Декоратор

`@singledispatchmethod` - это декоратор из модуля `functools`

- Сначала определяется базовый метод, который устанавливает работу функции(в нашем случае `__init__`) по умолчанию и применяем к нему `@singledispatchmethod`

```py
@singledispatchmethod
def __init__(self, name, breed):
    self._name = name
    self._breed = breed
```

- Далее определяем альтернативные методы в. **зависимости от типа данных первого переданного аргумента** в инициализатор после `self` и применяем к нему `@<name_based_method>.register(<data_type>)`

```py
@__init__.register(list)
def _from_list(self, data_list):
    self._name, self._breed = data_list
```

> название функции в декораторе `@<name_based_method>.register` **должно отличаться от названия** основного метода
